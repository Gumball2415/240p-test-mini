;
; Game Boy Color-exclusive tests for 240p test suite
; Copyright 2018 Damian Yerrick
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License along
; with this program; if not, write to the Free Software Foundation, Inc.,
; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
;
include "src/gb.inc"
include "src/global.inc"

  rsset hTestState
curhelpsect rb 1
curpalette rb 1
curvolume rb 1
cur_lcdc rb 1

; Game Boy Color tests menu ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
section "gbctestmenu", ROM0
activity_about_gbc_tests:
  ld a,PADF_A|PADF_B|PADF_START|PADF_LEFT|PADF_RIGHT
  ld b,helpsect_color_tests
  jp helpscreen

;;
; Ensures that the machine is color before 
activity_gbc_tests_menu::
  ld a,[initial_a]
  cp $11
  jr nz,activity_about_gbc_tests

.loop:
  ld a,PADF_A|PADF_B|PADF_START|PADF_DOWN|PADF_UP|PADF_LEFT|PADF_RIGHT
  ld b,helpsect_color_tests_menu
  call helpscreen

  ; B to return to the main menu
  ld hl,new_keys
  bit PADB_B,[hl]
  ret nz

  ; Save menu selection and get the index into the handler list
  ld a,[help_wanted_page]
  ld c,a
  ld a,[help_cursor_y]
  ld b,a
  push bc

  ; Start does About instead of what is selected
  bit PADB_START,[hl]
  jr z,.not_start
    call activity_about_gbc_tests
    jr .skip_activity
  .not_start:

  ; Get the handler for this activity
  ld de,color_handlers
  call de_index_a
  call jp_hl
.skip_activity:

  ; Restore menu selection
  pop bc
  ld a,b
  ld [help_cursor_y],a
  ld a,c
  ld [help_wanted_page],a
  jr .loop

color_handlers:
  dw activity_pluge
  dw activity_gradient_bars
  dw activity_smpte_bars
  dw activity_barsongray
  dw activity_color_bleed

; PLUGE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "pluge", ROM0
pluge_palette_ntsc:
  drgb $101010
  drgb $181818
  drgb $080808
  drgb $080808
  drgb $686868
  drgb $989898
  drgb $c8c8c8
  drgb $f8f8f8

pluge_palette_ntscj:
  drgb $000000
  drgb $080808
  drgb $080008
  drgb $000800

activity_pluge:
  xor a
  ldh [curpalette],a
.restart:
  call clear_gbc_attr

  ; Load tiles and map
  ld hl,CHRRAM0
  ld de,plugetiles_chr
  ld b,5
  call pb16_unpack_block
  ld hl,_SCRN0
  ld de,pluge_rowmap
  call smpte_load_map
  ld hl,pluge_palette_ntsc
  ld bc,16*256+low(rBCPS)
  ld a,$80
  call set_gbc_palette

  ld a,$FF
  ldh [rLYC],a
  ld a,LCDCF_ON|BG_NT0|BG_CHR01
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

.loop:
  ld b,helpsect_pluge
  call read_pad_help_check
  jr nz,.restart

  ld a,[new_keys]
  ld b,a
  bit PADB_B,b
  ret nz
  bit PADB_A,b
  jr z,.notogglepalette
    ldh a,[curpalette]
    cpl
    ldh [curpalette],a
  .notogglepalette:

  call wait_vblank_irq

  ; Load palette and tiles
  ld hl,pluge_palette_ntsc
  ldh a,[curpalette]
  or a
  jr z,.notloadlight
    ld hl,pluge_palette_ntscj
  .notloadlight:
  ld a,$80
  ld bc,(1*8)*256+low(rBCPS)
  call set_gbc_palette

  jr .loop

; Gradient color bars ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "gradientbars", ROM0
gradient_objpalette:
  drgb $000000
  drgb $080000
  drgb $100000
  drgb $180000
  drgb $000000
  drgb $000800
  drgb $001000
  drgb $001800
  drgb $000000
  drgb $000008
  drgb $000010
  drgb $000018
  drgb $000000
  drgb $080808
  drgb $101010
  drgb $181818

gradient_labels:
  db  32,  8,"0",10
  db  48,  8,"2",10
  db  64,  8,"4",10
  db  80,  8,"6",10
  db  96,  8,"8",10
  db 112,  8,"A",10
  db 128,  8,"C",10
  db 144,  8,"E",10
  db   4, 16,"Red",10
  db   4, 48,"Green",10
  db   4, 80,"Blue",10
  db   4,112,"White",0

activity_gradient_bars:
  ld a,LCDCF_ON|BG_NT0|BG_CHR01|LCDCF_OBJON
  ldh [cur_lcdc],a
.restart:
  call clear_gbc_attr

  ; Load tiles and map
  ld hl,CHRRAM0
  ld de,gradientcolorbartiles_chr
  ld b,5
  call pb16_unpack_block
  ld hl,_SCRN0
  ld de,gradient_rowmap
  call smpte_load_map
  ld hl,_SCRN1
  ld de,gradient_rowmap
  call smpte_load_map
  call gradient_load_oam
  ld de,(CHRRAM0 >> 4)|$04
  ld hl,gradient_labels
  call vwfDrawLabels
  
  ; Add grid to map
  ld hl,_SCRN1
  ld bc,65536-32*18
  .addgridloop:
    ld a,[hl]
    or a
    jr nz,.addgridnz
      ld a,$03  ; grid tile
    .addgridnz:
    ld [hl+],a
    inc c
    jr nz,.addgridloop
    inc b
    jr nz,.addgridloop

  ld a,IEF_LCDC|IEF_VBLANK
  ldh [rIE],a
  ld a,STATF_LYC
  ldh [rSTAT],a
  ld a,8
  ldh [rLYC],a

  ld a,%11110111
  call set_bgp
  ld hl,gradient_objpalette
  ld bc,32*256+low(rOCPS)
  ld a,$80
  call set_gbc_palette

  ldh a,[cur_lcdc]
  ld [vblank_lcdc_value],a
  ld [stat_lcdc_value],a
  ldh [rLCDC],a

.loop:
  ld b,helpsect_gradient_color_bars
  call read_pad_help_check
  jr nz,.restart

  ld a,[new_keys]
  ld b,a
  bit PADB_B,b
  ret nz
  bit PADB_A,b
  jr z,.not_toggle_grid
    ldh a,[cur_lcdc]
    xor LCDCF_BG9C00
    ldh [cur_lcdc],a
    ld [vblank_lcdc_value],a
    ld [stat_lcdc_value],a
  .not_toggle_grid:

  call wait_vblank_irq
  ld a,8
  ld de,%000000000000001
  call gradient_push_palette
  ld a,40
  ld de,%000000000100000
  call gradient_push_palette
  ld a,72
  ld de,%000010000000000
  call gradient_push_palette
  ld a,104
  ld de,%000010000100001
  call gradient_push_palette
  jr .loop

gradient_load_oam:
  ld hl,SOAM
  ld de,$18FF
  call .threepairpair
  call .threepairpair
  ld a,l
  ld [oam_used],a
  call lcd_clear_oam
  jp run_dma
.threepairpair:
  call .threepair
.threepair:
  ld a,d
  add 8
  ld d,a
  inc e
  call .onepair
  call .onepair
.onepair:
  ld a,d    ; y position
  ld [hl+],a
  ld a,32+8 ; x position
  ld [hl+],a
  ld a,$01  ; tile number
  ld [hl+],a
  ld a,e    ; attribute
  ld [hl+],a
  ld a,d
  ld [hl+],a
  add 8
  ld d,a
  ld a,40+8
  ld [hl+],a
  ld a,$02
  ld [hl+],a
  ld a,e    
  ld [hl+],a
  ret

gradient_push_palette:
  ; Prepare to wait for scanline A
  di
  ld b,a
  ldh [rLYC],a
  ld a,STATF_LYC
  ldh [rSTAT],a

  ; Construct initial color
  ld h,d
  ld l,e
  add hl,hl
  add hl,hl
  ld bc,7*256+low(rBCPD)
  ld a,$88
  ldh [rBCPS],a  ; seek in palette memory

  halt  ; Wait for LY=LYC
  
  ; Now get ready to wait for hblank interrupts
  ld a,STATF_MODE00
  ldh [rSTAT],a
  .lineloop:
    xor a
    ldh [rIF],a
    halt
    rept 4
      ld a,l
      ld [$FF00+c],a
      ld a,h
      ld [$FF00+c],a
      add hl,de
    endr
    dec b
    jr nz,.lineloop
  ld a,STATF_LYC
  ldh [rSTAT],a
  reti

; SMPTE color bars & Color bars on gray ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; There's no wave channel period that is exactly 1 kHz, but there's
; a 500 Hz.  So load the wave RAM with two sine cycles and play that.
HALF_KHZ equ 2048-131

section "smptebars", ROM0
smpte_palette_dark:
  drgb $C0C0C0  ; white-green
  drgb $C0C010
  drgb $10C0C0
  drgb $10C010
  drgb $1010C0  ; blue-green
  drgb $C01010
  drgb $C010C0
  drgb $10C010
  drgb $C0C0C0  ; row 2: nonblue colors replaced with black
  drgb $101010
  drgb $10C0C0
  drgb $101010
  drgb $1010C0
  drgb $101010
  drgb $C010C0
  drgb $101010

  drgb $101010
  drgb $300068  ; purple (Q)
  drgb $FFFFFF  ; bright white
  drgb $002050  ; blue (I)
  drgb $101010  ; shade2 (black)
  drgb $080808  ; shade1
  drgb $181818  ; shade3
  drgb $FF00FF

smpte_palette_light:
  drgb $FFFFFF  ; white-green
  drgb $FFFF10
  drgb $10FFFF
  drgb $10FF10
  drgb $1010FF  ; blue-green
  drgb $FF1010
  drgb $FF10FF
  drgb $10FF10
  drgb $FFFFFF  ; row 2: nonblue colors replaced with black
  drgb $101010
  drgb $10FFFF
  drgb $101010
  drgb $1010FF
  drgb $101010
  drgb $FF10FF
  drgb $101010

smpte_rowdata:
  db $00,$00,$00,$00,$00,$00,$00,$00,$00,$00, $00,$00,$00,$00,$00,$00,$00,$00,$00,$00  ; gray
  db $00,$00,$04,$01,$01,$05,$02,$02,$06,$03, $93,$96,$92,$92,$95,$91,$91,$94,$90,$90  ; SMPTE1
  db $30,$30,$34,$31,$31,$35,$32,$32,$36,$33, $a3,$a6,$a2,$a2,$a5,$a1,$a1,$a4,$a0,$a0  ; SMPTE2
  db $43,$43,$43,$47,$42,$42,$42,$41,$41,$41, $48,$40,$40,$40,$51,$50,$52,$50,$50,$50  ; SMPTE3
  db $10,$10,$14,$11,$11,$15,$12,$12,$16,$13, $83,$86,$82,$82,$85,$81,$81,$84,$80,$80  ; SMPTE1 flipped
  db $00,$00,$00,$00,$02,$02,$11,$12,$21,$22, $31,$32,$41,$42,$51,$52,$61,$62,$71,$72  ; gradient
  db $00,$00,$01,$01,$00,$00,$04,$04,$00,$00, $13,$13,$13,$13,$13,$13,$13,$13,$00,$00  ; pluge 1
  db $00,$00,$01,$01,$00,$00,$04,$04,$00,$00, $12,$12,$12,$12,$12,$12,$12,$12,$00,$00  ; pluge 2
  db $00,$00,$01,$01,$00,$00,$04,$04,$00,$00, $11,$11,$11,$11,$11,$11,$11,$11,$00,$00  ; pluge 3
  db $00,$00,$01,$01,$00,$00,$04,$04,$00,$00, $10,$10,$10,$10,$10,$10,$10,$10,$00,$00  ; pluge 4
smpte_rowmap:
  db $B1,$22,$53,$00
ongray_rowmap:
  db $30,$41,$40,$44,$30,$00
gradient_rowmap:
  db $20,$35,$10,$35,$10,$35,$10,$35,$10,$00
pluge_rowmap:
  db $10,$46,$47,$48,$49,$10,$00

;;
; @param DE
smpte_load_map:
.rowgrploop:
  ld a,[de]  ; A: which row
  inc de
  or a
  ret z
  push de
  push af  ; Stack: height, rowmap pos

  ; Set DE to smpte_rowdata[A & 0x0F]
  and $0F
  ld e,a
  add a  ; row*2
  add a  ; row*4
  add e  ; row*5
  add a  ; row*10
  add a  ; row*20
  ld de,smpte_rowdata
  add e
  ld e,a
  jr nc,.rowdata_no_wrap
    inc d
  .rowdata_no_wrap:
  pop af  ; Stack: rowmap pos
  swap a
  and $0F
  ld b,a   ; B: height of this segment in rows; DE: src; HL: dst
  ld c,20
  .rowloop:
    push de
    push bc   ; Stack: height, rowdata start, rowmap pos
    .byteloop:
      ; Copy the tile number
      ld a,[de]  ; A[3:0]: tilenumber
      and $0F
      ld [hl],a

      ; Copy the attribute
      ld a,1
      ldh [rVBK],a
      ld a,[de]  ; A[7]: hflip; A[6:4]: palette
      swap a
      and $0F
      bit 3,a
      jr z,.nb3
        xor %00101000
      .nb3:
      ld [hl+],a
      xor a
      ldh [rVBK],a
      inc de
      dec c
      jr nz,.byteloop
    ld de,12
    add hl,de
    pop bc
    pop de  ; Stack: rowmap pos
    dec b
    jr nz,.rowloop
  pop de
  jr .rowgrploop

activity_barsongray:
  ld a,helpsect_color_bars_on_gray
  jr smpte_bars_engine
activity_smpte_bars:
  ld a,helpsect_smpte_color_bars
smpte_bars_engine:
  ldh [curhelpsect],a
  xor a
  ldh [curpalette],a
  ldh [curvolume],a

.restart:
  call clear_gbc_attr

  ; Load palette and tiles
  ld a,$80
  ld bc,(6*8)*256+low(rBCPS)
  ld hl,smpte_palette_dark
  call set_gbc_palette
  ld hl,CHRRAM0
  ld de,smptetiles_chr
  ld b,9
  call pb16_unpack_block
  ld de,smpte_rowmap
  ldh a,[curhelpsect]
  cp helpsect_smpte_color_bars
  jr z,.not_load_alternate
    ld de,ongray_rowmap
  .not_load_alternate:
  ld hl,_SCRN0
  call smpte_load_map

  ld a,$80
  ldh [rNR52],a  ; Bring audio circuit out of reset
  ld a,$FF
  ldh [rNR51],a  ; Set panning
  ld a,$77
  ldh [rNR50],a  ; Set master volume
  ld hl,waveram_sin2x
  call load_waveram
  ldh a,[curvolume]
  ldh [rNR32],a
  ld a,low(HALF_KHZ)
  ldh [rNR33],a
  ld a,high(HALF_KHZ)
  or $80
  ldh [rNR34],a

  ld a,$FF
  ldh [rLYC],a  ; disable lyc irq
  ld a,LCDCF_ON|BG_NT0|BG_CHR01
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a
.loop:
  ldh a,[curhelpsect]
  ld b,a
  call read_pad_help_check
  jr nz,.restart

  ld a,[new_keys]
  ld b,a
  bit PADB_B,b
  jr z,.no_quit
    xor a
    ld [rNR52],a  ; stop audio circuit
    ret
  .no_quit:
  bit PADB_A,b
  jr z,.notogglepalette
    ldh a,[curpalette]
    cpl
    ldh [curpalette],a
  .notogglepalette:
  bit PADB_SELECT,b
  jr z,.notogglevol
    ldh a,[curvolume]
    xor $20
    ldh [curvolume],a
  .notogglevol:

  call wait_vblank_irq

  ; Load palette and tiles
  ld hl,smpte_palette_dark
  ldh a,[curpalette]
  or a
  jr z,.notloadlight
    ld hl,smpte_palette_light
  .notloadlight:
  ld a,$80
  ld bc,(4*8)*256+low(rBCPS)
  call set_gbc_palette
  ldh a,[curvolume]
  ldh [rNR32],a

  jr .loop

; Color bleed test ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This shares code with Full screen stripes in stills.z80.

section "colorbleed", ROM0
color_bleed_palette:
  drgb $000000
  drgb $FFFFFF
  drgb $000000
  drgb $000000
  drgb $000000
  drgb $FF0000
  drgb $000000
  drgb $000000
  drgb $000000
  drgb $00FF00
  drgb $000000
  drgb $000000
  drgb $000000
  drgb $0000FF
  drgb $000000
  drgb $000000
color_bleed_palette_end:

activity_color_bleed::
  ld a,helpsect_color_bleed
  jp full_stripes_common

load_color_bleed::
  ; Load plane 0
  ld hl,_SCRN0
  ld a,$06  ; blank tile
  ld c,32*2+2
  call memset_tiny
  ld b,4
  .p0rowgrploop:
    ld d,3
    .p0rowloop:
      ld a,$10  ; pattern tile
      ld c,16
      call memset_tiny
      ld a,$06  ; blank tile
      ld c,16
      call memset_tiny
      dec d
      jr nz,.p0rowloop
    ld c,32  ; blank row
    call memset_tiny
    dec b
    jr nz,.p0rowgrploop

  ; Load attributes
  ld a,1
  ldh [rVBK],a
  ld hl,_SCRN0
  ld c,6*32
  call memset_tiny
  inc a
  ld c,4*32
  call memset_tiny
  inc a
  ld c,4*32
  call memset_tiny
  xor a
  ld c,4*32
  call memset_tiny
  ldh [rVBK],a
  
  ; Load palette
  ld a,$80
  ld bc,(color_bleed_palette_end-color_bleed_palette)*256+low(rBCPS)
  ld hl,color_bleed_palette
  jp set_gbc_palette
