;
; Still image (or mostly so) tests for 240p test suite
; Copyright 2018 Damian Yerrick
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License along
; with this program; if not, write to the Free Software Foundation, Inc.,
; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
;
include "src/gb.inc"
include "src/global.inc"

  rsset hLocals
tilesleft rb 1

  rsset hTestState
curpalette rb 1
curtileid rb 1
curscry rb 1
curlcdc rb 1
lastlcdc rb 1
customred   rb 1
customgreen rb 1
customblue  rb 1
bleed_help_page rb 1

section "stillswram", WRAM0
curframe_bcd:: ds 1

; Gray ramp ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "grayramp",ROM0

gray_ramp_sgb_rects:
  db $04*8+2  ; 3 packets hold up to 5 rectangles
  db 5      ; number of rectangles

  ; Rectangle 1 of 5: Set whole screen as follows
  ; [0 2 2 0]
  ; [0 2 2 0]
  db %00000111  ; bit 0: inside, 1: border, 2: outside
  db %00001010  ; inside and border to palette 2, outside to palette 0
  db 5, 1, 14, 16  ; l, t, r, b, inclusive

  ; Rectangle 2 of 5: Set second to palette 1
  db %00000001
  db %00000001
  db 5, 1, 9, 8

  ; Rectangle 3 of 5: Set seventh to palette 1
  db %00000001
  db %00000001
  db 10, 9, 14, 16

  ; Rectangle 4 of 5: Set fourth to palette 3
  db %00000001
  db %00001111
  db 15, 1, 19, 8

  ; Rectangle 5 of 5: Set fifth to palette 3
  db %00000001
  db %00000011
  db 0, 9, 4, 16

;;
; Expand A tiles from DE to HL
; DE must be 4 byte aligned
load_gray_ramp_tiles:
  ld [tilesleft],a
  ld b,4
  .rowpairloop:
    ld c,4
    .byteloop:
      ld a,[de]
      inc e
      ld [hl+],a
      dec c
      jr nz,.byteloop
    ld a,e
    sub 4
    ld e,a
    dec b
    jr nz,.rowpairloop

  ; Did it wrap to the next page?
  add 4
  ld e,a
  jr nc,.enotwrapped
    inc d
  .enotwrapped:
  ld a,[tilesleft]
  dec a
  jr nz,load_gray_ramp_tiles
  ret

gray_ramp_row_cmp_d_sub_e:
  ld b, 20
  .byteloop:
    ld [hl+], a
    inc a
    cp d
    jr c,.nosube
      sub e
    .nosube:
    dec b
    jr nz, .byteloop
  jp add_hl_12

load_gray_ramp_sgb:
  ld de, grayramp_sgb_chr
  ld a, 9
  call load_gray_ramp_tiles

  ; Now the tilemap
  ; Row 0
  ld hl,_SCRN0
  call oneblanktilerow

  ; Rows 1-8
  ld c, 8
  .tophalfrowloop:
    ld a, 1
    ld de, $0605
    call gray_ramp_row_cmp_d_sub_e
    dec c
    jr nz,.tophalfrowloop
  ; Rows 9-16
  ld c, 8
  .bottomhalfrowloop:
    ld de, $0A05
    ld a, e
    call gray_ramp_row_cmp_d_sub_e
    dec c
    jr nz,.bottomhalfrowloop

  call oneblanktilerow
  ld a,%11100100
  ldh [rBGP], a
  ld hl, gray_ramp_sgb_rects
  jp sgb_send

load_gray_ramp_mono:

  ; Tiles 1-24 are compressed: 2 rows (4 bytes) are written 4 times
  ld de,grayramp_chr
  ld a,24
  call load_gray_ramp_tiles

  ; Now the tilemap
  ; Row 0
  ld hl,_SCRN0
  call oneblanktilerow

  ; Rows 1-8
  ld c,8
  .tophalfrowloop:
    xor a
    ld de, $1313
    call gray_ramp_row_cmp_d_sub_e
    dec c
    jr nz,.tophalfrowloop
  ; Rows 9-16
  ld c,8
  .bottomhalfrowloop:
    ld b,20
    ld de,grayramp_bottomhalfmap
    .bottomhalfbyteloop:
      ld a,[de]
      inc de
      ld [hl+],a
      dec b
      jr nz,.bottomhalfbyteloop
    call add_hl_12
    dec c
    jr nz,.bottomhalfrowloop
  ld a,%00011011
  ldh [rBGP], a
  ; Row 19
  jp oneblanktilerow

load_gray_ramp_gbc:

  ; Tiles 1-3 are a cycle of the gray ramp, and tile 4-5 is solid
  ; to fill in half of the color 0 tile
  ld b,7
  ld de,grayramp_chr_gbc
  call pb16_unpack_block

  ; Set gray ramp palette
  ld a,$80
  ldh [rBCPS],a
  ldh [rOCPS],a
  ld b,0
  .palloop:
    ; calculate 01237654
    ld a,b
    bit 2,a
    jr z,.notdesc
      xor $03
    .notdesc:

    ; calculate $401*a
    ld e,a
    ld l,a
    add a
    add a
    ld d,a

    ; add $20*b
    ld h,0
    add hl,hl
    add hl,hl
    add hl,hl
    add hl,hl
    add hl,hl
    add hl,de

    ; and write to the VCE
    ld a,l
    ldh [rBCPD],a
    ldh [rOCPD],a
    ld a,h
    ldh [rBCPD],a
    ldh [rOCPD],a
    inc b
    ld a,b
    cp 32
    jr nz,.palloop

  ld de,gray_ramp_rowmap
  ld hl,_SCRN0
  call smpte_load_map

  ; Because each vertical stripe is 5 pixels wide, the change from
  ; e.g. palette 0 to 1 occurs in the middle of a tile.  This would
  ; cause attribute clash.  So fill the gap with sprites using
  ; solid tile $04.
  ; B: x, C: y; D: attr counter; E: attr xor
  ld hl,SOAM
  ld bc,24*256+24
  ld de,$0081
  .filloamloop:
    ld a,b
    ld [hl+],a  ; write Y
    ld a,c
    ld [hl+],a  ; write X
    add 40
    ld c,a
    ld a,$04
    ld [hl+],a  ; write tile number
    ld a,d
    xor e
    ld [hl+],a  ; write attribute
    ld a,d
    add 2
    cp 8
    jr c,.have_new_oam_attr
      ; Prepare for next row
      ld a,16
      add b
      cp 24+128
      jr nc,.filloamdone
      ld b,a
      cp 24+64
      jr nz,.oamnothalfway
        ld e,$A6
      .oamnothalfway:
      ld c,24
      xor a
      
    .have_new_oam_attr:
    ld d,a
    jr .filloamloop
  .filloamdone:
  ret

oneblanktilerow:
  xor a
oneconsttilerow:
  ld c,20
  call memset_tiny
add_hl_12:
  ld de,12
  add hl,de
  ret

activity_gray_ramp::
.restart:
  call clear_gbc_attr
  ld [oam_used],a
  call lcd_clear_oam
  xor a
  ld hl,CHRRAM0
  ld c,16
  call memset_tiny
  dec a
  ldh [rLYC],a  ; disable lyc irq

  ld a,[initial_a]
  cp $11
  jr z,.load_gbc
  ld a,[is_sgb]
  or a
  jr z,.load_mono
    call load_gray_ramp_sgb
    ld bc, $0809
    ld de, $0A0B
    call sgb_set_palettes_bcde
    jr .load_done
  .load_mono:
    call load_gray_ramp_mono
    jr .load_done
  .load_gbc:
    call load_gray_ramp_gbc
  .load_done:

  ; Turn on rendering
  call run_dma
  ld a,LCDCF_ON|BG_NT0|BG_CHR01|OBJ_8X16
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

  ; Now just wait for a B press.  Fortunately, we don't have
  ; to deal with half B presses or parallel universes here.
.loop:
  ld b,helpsect_gray_ramp
  call read_pad_help_check
  jr nz,.restart
  call wait_vblank_irq
  ld a,[new_keys]
  bit PADB_B,a
  jr z,.loop
  ret

; Linearity ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

linearity_SCRN0_pivot = _SCRN0 + _SCRN0 + 32 * 17 + 19

section "linearity",ROM0
activity_linearity::
  ld a,%00011011
  ldh [curpalette],a
  ld a,LCDCF_ON|BG_NT0|BG_CHR21
  ldh [curlcdc],a

.restart:
  call clear_gbc_attr
  call sgb_set_palette_gray

  ld de,linearity_quadrant_iu
  ld hl,CHRRAM2
  call unpack_iu_file
  ld hl,_SCRN0+640
  ld de,_SCRN0
  ld bc,256*10+9
  call load_nam

  ; Reflect top left quadrant of tilemap into top right
  ld de,_SCRN0
  ld b, 9
  .nam_hflip_rowloop:
    ld c, 10
    ld hl, 19
    add hl, de
    .nam_hflip_byteloop:
      ld a, [de]
      inc e
      xor $20
      ld [hl-], a
      dec c
      jr nz, .nam_hflip_byteloop
    ld hl, 32 - 10
    add hl, de
    ld d, h
    ld e, l
    dec b
    jr nz,.nam_hflip_rowloop

  ; Reflect top of tilemap into bottom
  ld de,_SCRN0
  ld b, 9
  .nam_vflip_rowloop:
    ld a, low(linearity_SCRN0_pivot)
    sub e
    ld l, a
    ld a, high(linearity_SCRN0_pivot)
    sbc d
    ld h, a
    ld c, 20
    .nam_vflip_byteloop:
      ld a, [de]
      inc e
      xor $5F
      ld [hl-], a
      dec c
      jr nz, .nam_vflip_byteloop
    ld hl, 32 - 20
    add hl, de
    ld d, h
    ld e, l
    dec b
    jr nz,.nam_vflip_rowloop

  ; Reflect tiles horizontally
  ld de, $9000
  ld hl, $9200
  .chr_hflip_loop:
    ld a, [de]
    inc de
    scf
    adc a
    .chr_hflip_bitloop:
      rr b
      add a
      jr nz, .chr_hflip_bitloop
    ld a, b
    ld [hl+], a
    ld a, h
    cp $94
    jr nz, .chr_hflip_loop

  ; Reflect tiles vertically
  ld de, $9000
  ld hl, $97FE
  .chr_vflip_loop:
    ld a, [de]
    inc e
    ld [hl+], a
    ld a, [de]
    inc de
    ld [hl-], a
    dec hl
    dec l
    ld a, d
    cp $94
    jr nz, .chr_vflip_loop

  ; Form full grid, copying already loaded tiles from CHRRAM2
  ; (default) to CHRRAM0 (nondefault)
  ld hl,CHRRAM2
  ld de,CHRRAM0
  ld c,128
  ld b,7
  .gridtileloop:
    push bc
    ; Top row: Copy plane 1 to plane 0 and set plane 1 to $FF
    inc hl
    ld a,[hl+]
    ld [de],a
    inc de
    ld a,$FF
    ld [de],a
    inc de
    ld b,7

    .gridsliverloop:
      ; Other rows: Copy plane 1 bit 7 and plane 0 bits 6-0 to
      ; plane 0, and plane 1 OR $80 to plane 1.
      ld a,[hl+]
      ld c,a
      ld a,[hl]
      xor c
      and $80
      xor c
      ld [de],a
      inc de
      ld a,[hl+]
      or $80
      ld [de],a
      inc de
      dec b
      jr nz,.gridsliverloop
  
    pop bc
    dec c
    jr nz,.gridtileloop

  ld a,255
  ldh [rLYC],a  ; disable lyc irq
  call set_bgp
  ldh a,[curlcdc]
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

.loop:
  ld b,helpsect_linearity
  call read_pad_help_check
  jp nz,.restart
  call wait_vblank_irq
  ldh a,[curpalette]
  call set_bgp

  ; Process input
  ld a,[new_keys]
  ld b,a

  bit PADB_SELECT,b
  jr z,.not_select
    ldh a,[curpalette]
    cpl
    ldh [curpalette],a
  .not_select:

  bit PADB_A,b
  jr z,.not_A
    ldh a,[curlcdc]
    xor BG_CHR21^BG_CHR01
    ld [curlcdc],a
    ldh [vblank_lcdc_value],a
  .not_A:

  bit PADB_B,b
  jr z,.loop
  ret


; Sharpness ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
section "sharpness",ROM0

  if 0
;;
; Loads a PB16-compressed 20x18-tile nametable to VRAM, using the
; last 384 bytes of nametable 0 as a temporary buffer.
; @param DE source
; @param HL destination (usually _SCRN0 or _SCRN1)
; @param B width (load_full_pb16_nam forces 20)
; @param C height (load_full_pb16_nam forces 18)
load_full_pb16_nam::
  ld bc,20*256+18
load_pb16_nam::
  push bc
  push hl
  ld hl,_SCRN0+640
  ld b,368/16
  call pb16_unpack_block
  pop de
  pop bc
  ld hl,_SCRN0+640
  jp load_nam
  endc

activity_sharpness::
  ld a,%00011011
  ldh [curpalette],a
  ld a,LCDCF_ON|BG_NT0|BG_CHR21
  ldh [curlcdc],a

.restart:
  call clear_gbc_attr

  ; Load primary picture
  ld de,sharpness_iu
  ld hl,CHRRAM2
  call unpack_iu_file
  ld hl,_SCRN0+640
  ld de,_SCRN0
  call load_full_nam

  ; Load secondary picture
  ld hl,sharpness_brick_tile
  ld de,CHRRAM2+$7F0
  ld bc,16
  call memcpy
  ld h,$7F
  ld de,_SCRN1
  ld bc,32*18
  call memset

  ld a,255
  ldh [rLYC],a  ; disable lyc irq
  call set_bgp
  ld a,[curlcdc]
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a
  cpl
  ldh [lastlcdc], a

.loop:
  ld b,helpsect_sharpness
  call read_pad_help_check
  jr nz,.restart
  call wait_vblank_irq

  ; Load the appropriate GB/GBC palette for what is showing
  ldh a,[curlcdc]
  and LCDCF_BG9C00
  jr z,.load_normal_palette
    ld a,%11100100
    ldh [rBGP],a
    ld a,$82
    ld bc,6*256+LOW(rBCPS)
    ld hl,sharpness_bricks_gbc_palette
    call set_gbc_palette
    jr .done_loading_palette
  .load_normal_palette:
    ldh a,[curpalette]
    call set_bgp
  .done_loading_palette:

  ; If it corresponds to a change in the SGB palette, dew it
  ldh a, [lastlcdc]
  ld c, a
  ldh a, [curlcdc]
  ldh [lastlcdc], a
  ld b, a
  xor c
  and LCDCF_BG9C00
  ; B: new LCDC value; C: old LCDC value;
  ; A: LCDCF_BG9C00 if changed else 0
  jr z, .no_sgb_palette_change
    and b
    jr z, .sgb_palette_not_zero
      ld a, 3
    .sgb_palette_not_zero:
    ld b, a
    call sgb_set_palette_b
  .no_sgb_palette_change:

  ; Process input
  ld a,[new_keys]
  ld b,a

  bit PADB_SELECT,b
  jr z,.not_select
    ldh a,[curpalette]
    cpl
    ldh [curpalette],a
  .not_select:

  bit PADB_A,b
  jr z,.not_A
    ldh a,[curlcdc]
    xor LCDCF_BG9C00
    ldh [curlcdc],a
    ld [vblank_lcdc_value],a
  .not_A:

  bit PADB_B,b
  jr z,.loop
  ret

; Solid screen ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "solidscreen",ROM0
solid_screen_constants:
  drgb $000000
  drgb $FF0000
  drgb $00FF00
  drgb $0000FF
activity_solid_screen::
  xor a
  ldh [curpalette],a
  ld a,31
  ldh [customred],a
  ldh [customgreen],a
  ldh [customblue],a
  ld a,$80
  ldh [curscry],a

.restart:
  call clear_gbc_attr
  call clear_sgb_attr
  call sgb_set_palette_gray

  ; Tile 0: Blank screen in color 0
  ; Tiles 1-0
  ld hl,CHRRAM2
  ld c,16
  xor a
  call memset_tiny
  dec a
  ldh [lastlcdc], a  ; lastlcdc: true if color changed
  ldh [rLYC],a  ; disable lyc irq
  ld c,9*16
  call memset_tiny

  ; Create VWF canvas at X=160-184, which only GBC/SGB will display
  call clear_scrn0_to_0
  ld a,1
  ld hl,_SCRN0+32*1+20
  ld b,3  ;  3 rows tall
  ld de,32-3
  .canvasinitrowloop:
    ld c,3
    call memset_inc
    add hl,de
    dec b
    jr nz,.canvasinitrowloop

  ld a,%11000000
  call set_bgp
  ld a,LCDCF_ON|BG_NT0|BG_CHR21
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

.loop:
  ld b,helpsect_solid_screen
  call read_pad_help_check
  jr nz,.restart
  call wait_vblank_irq

  ; Write color to both GB and GBC palette ports
  ld a, [initial_a]
  cp $11
  jr nz, .set_color_not_gbc
    call calc_custom_color
    ld a,$80
    ldh [rBCPS],a
    ld a,l
    ldh [rBCPD],a
    ld a,h
    ldh [rBCPD],a
    jr .custom_color_written
  .set_color_not_gbc:
  ld a, [is_sgb]
  or a
  ldh a, [curpalette]
  jr z, .set_color_dmg
    ; Super Game Boy: Write color only if changed
    ldh a, [lastlcdc]
    or a
    jr z, .custom_color_written
    call calc_custom_color
    call sgb_send_solid_color
    xor a
    ldh [lastlcdc], a
    ld a, %11100100
  .set_color_dmg:
  ldh [rBGP], a
  .custom_color_written:

  ; $80: Scroll to x=32 away from RGB control
  ; $00: Scroll to x=0 with RGB control
  ldh a,[curscry]
  and $80
  xor $80
  rra
  rra
  ldh [rSCX],a

  ; Choose among 5 palettes on GBC or 4 on GB
  ld a,[new_keys]
  bit PADB_B,a
  ret nz  ; quit now if exit
  ld b,a
  ld c,4
  ld a,[initial_a]
  cp $11
  jr z,.is_5_palettes
  ld a, [is_sgb]
  or a
  jr z, .not_5_palettes
  .is_5_palettes:
    ; A on white screen on GBC only: Toggle custom mode
    bit PADB_A,b
    jr z,.not_toggle_custom
    ldh a,[curpalette]
    or a
    jr nz,.not_toggle_custom
      ldh a,[curscry]
      xor $80
      ldh [curscry],a
    .not_toggle_custom:
    ld c,5
  .not_5_palettes:

  ; Process input
  ldh a,[curscry]
  rla
  jr c,.not_custom_control

    ; Autorepeat for left and right keys
    ld b,PADF_LEFT|PADF_RIGHT
    call autorepeat_60hz_if_sgb
    ld a,[new_keys]
    ld b,a
    ldh a,[curscry]

    ; At this point: A is which row is selected, and B
    bit PADB_DOWN,b
    jr z,.not_custom_next_row
      inc a
      cp 3
      jr c,.not_custom_next_row
      dec a
    .not_custom_next_row:

    bit PADB_UP,b
    jr z,.not_custom_prev_row
      dec a
      cp 3
      jr c,.not_custom_prev_row
      inc a
    .not_custom_prev_row:
    ldh [curscry],a

    add low(customred)
    ld c,a
    ld a,[$FF00+c]
    bit PADB_RIGHT,b
    jr z,.not_custom_increase
    cp 31
    jr nc,.not_custom_increase
      inc a
      ldh [lastlcdc], a
    .not_custom_increase:

    bit PADB_LEFT,b
    jr z,.not_custom_decrease
    or a
    jr z,.not_custom_decrease
      ldh [lastlcdc], a
      dec a
    .not_custom_decrease:
    ld [$FF00+c],a

    call solid_update_rgb
    jr .input_done
  .not_custom_control:
    bit PADB_LEFT,b
    jr z,.not_left
      ldh a,[curpalette]
      or a
      jr nz,.notwrapprev
        ld a,c
      .notwrapprev:
      dec a
      jr .have_new_curpalette
    .not_left:

    bit PADB_RIGHT,b
    jr z,.not_right
      ldh a,[curpalette]
      inc a
      cp c
      jr c,.notwrapnext
        xor a
      .notwrapnext:
    .have_new_curpalette:
      ldh [curpalette],a
      ld a, c
      ldh [lastlcdc], a
    .not_right:
  .input_done:
  jp .loop

calc_custom_color:
  ldh a, [curpalette]
  or a
  jr z,.is_custom
    ld de,solid_screen_constants-2
    jp de_index_a
  .is_custom:
  ld h,a     ; H = 0
  ldh a,[customgreen]
  add a,a
  add a,a
  add a,a
  ld l,a
  add hl,hl
  add hl,hl  ; HL = G * 32
  ldh a,[customred]
  ld e,a             ; E = R
  ldh a,[customblue]
  add a
  add a              ; A = B * 4
  ld d,a             ; DE = R+B*1024
  add hl,de
  ret

sgb_send_solid_color:
  ld a, $00*8+1
  ld [help_line_buffer+0], a
  ld a, l
  ld [help_line_buffer+1], a
  ld a, h
  ld hl,help_line_buffer+2
  ld [hl+], a
  ld a, $FF
  ld [hl+], a
  ld [hl+], a
  ld [hl+], a
  ld [hl+], a
  xor a
  ld c, 9
  call memset_tiny
  ld hl, help_line_buffer
  jp sgb_send

solid_update_rgb:
  ; Draw labels for Red, Green, and Blue
  call vwfClearBuf
  ld a,"R"
  ld b,6+24*0
  call vwfPutTile
  ld a,"G"
  ld b,6+24*1
  call vwfPutTile
  ld a,"B"
  ld b,6+24*2
  call vwfPutTile

  ; Draw cursor
  ldh a,[curscry]
  ld b,a
  add a  ; A=component*2
  add b  ; A=component*3
  add a  ; A=component*6
  add a  ; A=component*12
  scf
  adc a  ; A=component*24+1
  ld b,a
  ld a,">"
  call vwfPutTile

  ; Draw red, green, and blue values
  ld de,19 * 256 + low(customred)
.componentloop:
  push de
  ld c,e
  ld a,[$FF00+c]
  call bcd8bit  ; A: tens; C: ones
  jr z,.lessthanten
    push bc
    add "0"
    ld l,a
    ld a,d
    sub 5
    ld b,a  ; B:x, L: ascii, stack: ones digit, Y and hramptr
	ld a,l
    call vwfPutTile
    pop bc   ; Restore ones
    pop de   ; Restore Y and hramptr
    push de
  .lessthanten:
  ld a,c
  add "0"
  ld b,d
  call vwfPutTile
  pop de
  inc e
  ld a,24
  add d
  ld d,a
  cp 24*3
  jr c,.componentloop

  ; Push tiles to VRAM during blanking  
  ld hl,CHRRAM2+1*16
  ld c,9
  jp vwfPutBufHBlank

; CPS style grid ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "cpsgrid",ROM0
cps_grid_gbc_palette0:
  drgb $FFFFFF
  drgb $FF00FF
  drgb $FF0000
  drgb $000000
cps_grid_gbc_palette1:
  drgb $000000
  drgb $FF00FF
  drgb $FF0000
  drgb $FFFFFF

activity_cps_grid::
  ld a,%00011011
  ldh [curpalette],a

.restart:
  call clear_gbc_attr
  ld b, 2
  call sgb_set_palette_b

  ld hl,CHRRAM2
  ld de,cps_grid_chr
  ld b,sizeof_cps_grid_chr/16
  call pb16_unpack_block

  ; Draw grid
  ld hl,_SCRN0
  ld b,0  ; top red row
  call cps_grid_two_rows
  ld bc,$0407
  .rowloop:
    push bc
    call cps_grid_two_rows
    pop bc
    dec c
    jr nz,.rowloop
  ld b,c  ; bottom red row
  call cps_grid_two_rows

  ld a,255
  ldh [rLYC],a  ; disable lyc irq
  call set_bgp
  ld a,LCDCF_ON|BG_NT0|BG_CHR21
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

.loop:
  ld b,helpsect_grid
  call read_pad_help_check
  jr nz,.restart
  call wait_vblank_irq

  ; Set GB palette
  ldh a,[curpalette]
  ldh [rBGP],a

  ; Set GBC palette
  and %00001000
  ld e,a
  ld d,0
  ld hl,cps_grid_gbc_palette0
  add hl,de
  ld bc,8*256+low(rBCPS)
  ld a,$80
  call set_gbc_palette

  ; Process input
  ld a,[new_keys]
  ld b,a

  bit PADB_SELECT,b
  jr z,.not_select
    ldh a,[curpalette]
    cpl
    ldh [curpalette],a
  .not_select:

  bit PADB_B,b
  jr z,.loop
  ret

;;
; Draws one row of the CPS-2 grid.
cps_grid_two_rows:
  call cps_grid_one_row
  ; Move to bottom half
  inc b
  inc b
cps_grid_one_row:
  ; Left column
  ld a,b
  and $02
  ld [hl+],a
  inc a
  ld [hl+],a

  ; Center 8 columns
  ld c,16
  ld a,b
  .colloop:
    ld [hl+],a
    xor a,1
    dec c
    jr nz,.colloop

  ; Right column
  ld a,b
  and $02
  ld [hl+],a
  inc a
  ld [hl+],a
  inc a

  ; Move to next row
  ld de,12
  add hl,de
  ret

; Full screen stripes ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "fullstripes",ROM0,align[3]
bleed_types:
  db %00000000  ; horizontal
  db %11111111  ; horizontal xor
  db %01010101  ; vertical
  db %00000000  ; vertical xor
  db %01010101  ; diagonal
  db %11111111  ; vertical xor
word_frame:
  db "Frame ",0

;;
; @param A index into bleed_types
; @param B starting XOR value (alternates $00 and $FF)
; @param DE destination tile address
load_bleed_frame_a:
  ld hl,bleed_types
  add a,a
  add a,l
  ld l,a
  ld a,[hl+]  ; A = starting byte
  xor b       ; A = starting byte this frame
  ld c,[hl]   ; C = xor value by line
  ld h,d
  ld l,e
  ld b,8      ; bytes left in tile
  ld d,0      ; plane 1 value
  .loop:
    ld [hl+],a
    ld [hl],d
    inc l
    xor c
    dec b
    jr nz,.loop
  ret

activity_full_stripes::
  ld a,helpsect_full_screen_stripes
full_stripes_common::
  ldh [bleed_help_page],a
  xor a
  ldh [curtileid],a
  ldh [curscry],a
  ldh [curpalette],a
  ld [curframe_bcd],a
  ld a,LCDCF_ON|BG_NT0|BG_CHR01|LCDCF_WIN9C00
  ldh [curlcdc],a
.restart:
  call clear_gbc_attr

  ; Hide background (tile 16) until ready
;  xor a  ; A is 0 after clear_gbc_attr
  ld hl,CHRRAM0+256
  ld c,16
  call memset_tiny

  ; Make VWF window for frame number at (0, 0) on window
  ld hl,CHRRAM0
  ld c,112  ; 6 tiles window, 1 tile blank (for color bleed)
  ; A is still 0
  call memset_tiny
  ld hl,_SCRN1
  ld c,6
  ; A is still 0
  call memset_inc

  ld a,$FF
  ldh [rLYC],a  ; disable lyc irq

  ; Position the window
  ld a,167-48
  ldh [rWX],a
  ld a,144-8
  ldh [rWY],a

  ldh a,[bleed_help_page]
  cp helpsect_color_bleed
  jr z,.is_color_bleed
    ; Loading specific to "Full screen stripes"

    ; Blow away the tilemap
    ld h,16
    call clear_scrn0_to_h
    ld a,%00000011
    call set_bgp
    call sgb_set_palette_gray
    jr .specific_loading_done
  .is_color_bleed:
    call load_color_bleed
  .specific_loading_done:

  ; Turn on LCD
  ldh a,[curlcdc]
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

.loop:
  ldh a,[bleed_help_page]
  ld b,a
  call read_pad_help_check
  jr nz,.restart

  ; Process input
  ld b,PADF_UP|PADF_DOWN|PADF_LEFT|PADF_RIGHT
  call autorepeat_60hz
  ld a,[new_keys]
  ld b,a
  bit PADB_B,b
  ret nz

  ld a,PADF_UP|PADF_DOWN|PADF_LEFT|PADF_RIGHT
  and b
  jr z,.not_toggle
    ldh a,[curpalette]
    cpl
    ldh [curpalette],a
  .not_toggle:

  bit PADB_A,b
  jr z,.not_A
    ldh a,[curtileid]
    inc a
    cp 3
    jr c,.nowrap0
      xor a
    .nowrap0:
    ldh [curtileid],a
  .not_A:

  bit PADB_SELECT,b
  jr z,.not_select
    ldh a,[curlcdc]
    xor LCDCF_WINON
    ldh [curlcdc],a
    ld [vblank_lcdc_value],a
  .not_select:

  call wait_vblank_irq
  ldh a,[curpalette]
  ld b,a
  ld a,[curtileid]
  ld de,CHRRAM0+256
  call load_bleed_frame_a
  call update_bcd_frame_counter
  jr .loop

;;
; Update the frame counter
; @param HL destination address of frame counter tiles
update_bcd_frame_counter:
  ld hl,CHRRAM0+$000
  push hl

  ; Write "Frame "
  ld hl,help_line_buffer
  ld de,word_frame
  call stpcpy

  ; Increment and write the frame count
  ld a,[curframe_bcd]
  inc a
  daa
  cp $60
  jr c,.nowrap60
    xor a
  .nowrap60:
  ld [curframe_bcd],a
  call puthex

  ; Terminate the string
  xor a
  ld [hl],a

  ; And draw it
  call vwfClearBuf
  ld hl,help_line_buffer
  ld b,4  ; X position
  call vwfPuts
  pop hl
  ld c,6
  jp vwfPutBufHBlank

;;
; Copies a nul-terminated string.
; @param HL destination pointer
; @param DE source string, NUL-terminated
; @return DE and HL both point to the trailing NUL
stpcpy::
  .loop:
    ld a,[de]
    and a
    jr z,.done
    ld [hl+],a
    inc de
    jr .loop
  .done:
  ld [hl],a
  ret
